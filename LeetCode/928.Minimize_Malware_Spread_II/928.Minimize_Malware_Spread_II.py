#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from collections import defaultdict


class UnionFind:

    def __init__(self, n):
        self.parent = list(range(n))
        self.size = [1] * n

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, x, y):
        rx, ry = self.find(x), self.find(y)
        if rx == ry:
            return False
        if self.size[rx] < self.size[ry]:
            rx, ry = ry, rx
        self.size[rx] += self.size[ry]
        self.parent[ry] = rx
        return True


class Solution:
    def minMalwareSpread(self, graph: list[list[int]], initial: list[int]) -> int:
        n = len(graph)
        uf = UnionFind(n)

        initial_set = set(initial)

        # union node no including initial node
        # call it clean component
        for i in range(n):
            if i in initial_set:
                continue
            for j in range(i + 1, n):
                if graph[i][j] == 1 and j not in initial_set:
                    uf.union(i, j)

        # [clean component]:set(initial node)
        touch = defaultdict(set)
        for i in initial:
            seen = set()  # remove duplicate components
            for j in range(n):
                if i == j:
                    continue
                elif graph[i][j] == 1 and j not in initial_set:
                    parent = uf.find(j)
                    if parent not in seen:
                        seen.add(parent)
                        touch[parent].add(i)

        # when len(set(initial node)) == 1
        # means only 1 initial node can access this component
        # init_node: sum(access clean component size)
        init_node = defaultdict(int)
        for parent, nodes in touch.items():
            if len(nodes) == 1:
                only_src = next(iter(nodes))
                init_node[only_src] += uf.size[parent]

        initial.sort()
        best = initial[0]
        save = -1

        for i in initial:
            if init_node[i] > save:
                best = i
                save = init_node[i]

        return best
